<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>수능 공부 달력</title>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            margin: 20px;
            background-color: #f9f9f9;
        }
        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 20px;
        }
        .top-controls {
            text-align: center;
            margin-bottom: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px; /* 버튼 간 간격 */
            flex-wrap: wrap; /* 작은 화면에서 줄바꿈 */
        }
        .top-controls button {
            padding: 10px 20px;
            font-size: 1em;
            color: #fff;
            background-color: #007bff;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }
        .top-controls button:hover {
            background-color: #0056b3;
        }
        .month-navigation {
            display: flex;
            align-items: center;
            gap: 15px;
            margin: 0 20px; /* 좌우 여백 */
        }
        .month-navigation button {
            background-color: #28a745; /* 월 이동 버튼 색상 */
        }
        .month-navigation button:hover {
            background-color: #218838;
        }
        #currentMonthDisplay {
            font-size: 1.5em;
            font-weight: bold;
            color: #444;
            min-width: 150px; /* 월 표시 영역 최소 너비 */
        }

        .calendar-container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            justify-content: center;
        }
        .month-block {
            background-color: #fff;
            border: 1px solid #ddd;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 15px;
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
        }
        .month-title {
            text-align: center;
            font-size: 1.5em;
            color: #444;
            margin-bottom: 15px;
            font-weight: bold;
            display: none; /* 월 이동 버튼이 있으므로 중복 제거 */
        }
        .calendar-table {
            width: 100%;
            border-collapse: collapse;
        }
        .calendar-table th, .calendar-table td {
            border: 1px solid #eee;
            padding: 12px;
            text-align: center;
            vertical-align: top;
            min-height: 100px;
            box-sizing: border-box;
            width: calc(100% / 7);
        }
        .calendar-table th {
            background-color: #e9e9e9;
            font-weight: bold;
            color: #555;
        }
        .calendar-table td {
            background-color: #fdfdfd;
            font-size: 0.9em;
            color: #666;
            /* 기본적으로 모든 셀은 클릭 가능하나, 편집은 JavaScript로 제어 */
            cursor: default; 
        }
        .calendar-table td.today {
            background-color: #ffe0e0;
            border: 2px solid #d9534f;
            color: #d9534f;
        }
        .calendar-table td.today .date-number {
             color: #d9534f;
        }
        .calendar-table td.future-start {
             background-color: #f0f8ff;
             border: 1px dashed #a8d0ed;
        }
        .calendar-table td.different-month {
            color: #ccc;
            background-color: #fafafa;
        }
        .date-number {
            font-weight: bold;
            font-size: 1.1em;
            color: #333;
            margin-bottom: 5px;
            display: block;
            pointer-events: none;
        }
        .task-list {
            list-style: none;
            padding: 0;
            margin-top: 5px;
            font-size: 0.85em;
            line-height: 1.3;
            text-align: left;
        }
        .task-list li {
            margin-bottom: 3px;
            display: flex;
            align-items: flex-start;
            position: relative;
        }
        .task-list li input[type="checkbox"] {
            margin-right: 5px;
            flex-shrink: 0;
            margin-top: 3px;
        }
        .task-content {
            flex-grow: 1;
            outline: none;
            word-break: break-word;
            min-height: 1.3em;
            /* 기본적으로 편집 불가능하게 설정 (스크립트가 변경) */
            contenteditable: false; 
            cursor: pointer; /* 클릭 가능한 것처럼 보이게 */
        }
        /* 편집 가능할 때의 스타일 */
        .task-content[contenteditable="true"] {
            background-color: #fffacd; /* 편집 모드일 때 배경색 */
            border: 1px dashed #ccc;
        }
        .delete-task-btn {
            background: none;
            border: none;
            color: #d9534f;
            font-size: 0.8em;
            cursor: pointer;
            padding: 0 3px;
            margin-left: 5px;
            line-height: 1;
            opacity: 0; /* 기본적으로 숨김 */
            transition: opacity 0.2s ease-in-out;
        }
        /* 편집 가능한 항목에 마우스 오버 시 삭제 버튼 표시 */
        .task-list li:hover .delete-task-btn {
            opacity: 1;
        }

        /* 주말 색상 */
        .calendar-table th:first-child, .calendar-table td:nth-child(1) {
            color: #d9534f;
        }
        .calendar-table th:last-child, .calendar-table td:nth-child(7) {
            color: #337ab7;
        }
    </style>
</head>
<body>
    <h1 id="main-title">수능 공부 일정표</h1>
    <div class="top-controls">
        <div class="month-navigation">
            <button id="prevMonthBtn">◀ 이전 달</button>
            <span id="currentMonthDisplay"></span>
            <button id="nextMonthBtn">다음 달 ▶</button>
        </div>
        <button id="backupDataBtn">데이터 백업</button>
        <button id="restoreDataBtn">데이터 복원</button>
        <input type="file" id="restoreFileInput" accept=".json" style="display: none;">
    </div>
    <div class="calendar-container">
        </div>

    <script>
        // 오늘 날짜 설정 (시간 부분 초기화)
        const today = new Date();
        today.setHours(0, 0, 0, 0); 
        
        // 실제 일정 시작일 (2025년 7월 15일)
        const studyStartDate = new Date("2025-07-15T00:00:00");
        
        // 2025년 수능일 (11월 13일 목요일)
        const suneungDate = new Date("2025-11-13T00:00:00");

        const subjects = ["생윤", "생1"];
        const daysOfWeek = ["일요일", "월요일", "화요일", "수요일", "목요일", "금요일", "토요일"];

        const calendarContainer = document.querySelector('.calendar-container');
        const mainTitle = document.getElementById('main-title');
        const currentMonthDisplay = document.getElementById('currentMonthDisplay');
        const prevMonthBtn = document.getElementById('prevMonthBtn');
        const nextMonthBtn = document.getElementById('nextMonthBtn');
        const backupDataBtn = document.getElementById('backupDataBtn');
        const restoreDataBtn = document.getElementById('restoreDataBtn');
        const restoreFileInput = document.getElementById('restoreFileInput');

        let currentDisplayYear = today.getFullYear();
        let currentDisplayMonth = today.getMonth(); // 현재 보고 있는 달의 연도와 월

        // D-Day 계산 및 제목 업데이트 함수
        function updateDDay() {
            const diffTime = suneungDate.getTime() - today.getTime();
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)); // 밀리초를 일로 변환, 올림

            if (diffDays > 0) {
                mainTitle.textContent = `수능 공부 일정표 (수능까지 D-${diffDays}일)`;
            } else if (diffDays === 0) {
                mainTitle.textContent = `수능 공부 일정표 (수능 D-Day!)`;
            } else {
                mainTitle.textContent = `수능 공부 일정표 (수능 종료)`;
            }
        }

        // D-Day 초기 업데이트
        updateDDay();

        // 주어진 연월의 달력 데이터를 생성하고 HTML에 추가하는 함수
        function createMonthCalendar(year, month) {
            calendarContainer.innerHTML = ''; // 기존 달력 내용 지우기
            currentMonthDisplay.textContent = `${year}년 ${month + 1}월`; // 현재 표시 월 업데이트

            const firstDayOfMonth = new Date(year, month, 1);
            const lastDayOfMonth = new Date(year, month + 1, 0);
            
            const monthBlock = document.createElement('div');
            monthBlock.classList.add('month-block');
            
            const table = document.createElement('table');
            table.classList.add('calendar-table');
            monthBlock.appendChild(table);

            const thead = table.createTHead();
            const headerRow = thead.insertRow();
            daysOfWeek.forEach(day => {
                const th = document.createElement('th');
                th.textContent = day;
                headerRow.appendChild(th);
            });

            const tbody = table.createTBody();

            let currentDate = new Date(firstDayOfMonth);
            currentDate.setDate(firstDayOfMonth.getDate() - firstDayOfMonth.getDay());

            let calendarEndDate = new Date(lastDayOfMonth);
            if (lastDayOfMonth.getDay() !== 6) { 
                calendarEndDate.setDate(lastDayOfMonth.getDate() + (6 - lastDayOfMonth.getDay()));
            }

            let subjectIndex = 0; // 월이 바뀔 때마다 subjectIndex 초기화 (월별로 패턴 반복)

            while (currentDate <= calendarEndDate) {
                if (currentDate.getDay() === 0) { 
                    var weekRow = tbody.insertRow();
                }

                const cell = weekRow.insertCell();
                const cellDate = new Date(currentDate); 
                cellDate.setHours(0, 0, 0, 0); 

                if (cellDate.getMonth() !== month) {
                    cell.classList.add('different-month');
                } else {
                    const dateNumSpan = document.createElement('span');
                    dateNumSpan.classList.add('date-number');
                    dateNumSpan.textContent = cellDate.getDate();
                    cell.appendChild(dateNumSpan);

                    if (cellDate.getTime() === today.getTime()) {
                        cell.classList.add('today');
                    }
                    // future-start는 studyStartDate 이전이면서 오늘 이후인 날짜
                    if (cellDate < studyStartDate && cellDate >= today) { 
                        cell.classList.add('future-start');
                    }

                    const dateKey = cellDate.toISOString().split('T')[0]; 
                    let savedTasksString = localStorage.getItem(dateKey);

                    const taskList = document.createElement('ul');
                    taskList.classList.add('task-list');
                    
                    // 저장된 내용이 있다면 로드
                    if (savedTasksString) {
                        try {
                            const savedTasks = JSON.parse(savedTasksString);
                            savedTasks.forEach(task => {
                                const newLi = document.createElement('li');
                                // 편집 가능 여부는 여기서 결정하지 않고, 이벤트 리스너에서 동적으로 부여
                                newLi.innerHTML = `<input type="checkbox" ${task.checked ? 'checked' : ''}> <span class="task-content">${task.text}</span><button class="delete-task-btn">[X]</button>`;
                                taskList.appendChild(newLi);
                            });
                        } catch (e) {
                            console.error("Failed to parse saved content for date", dateKey, e);
                        }
                    } 
                    // 오늘 이후부터 수능일까지의 날짜에는 기본 내용 생성 (저장된 내용이 없을 때만)
                    else if (cellDate >= today && cellDate <= suneungDate && month !== 10) { 
                         generateDefaultTasks(taskList, cellDate, daysOfWeek, subjects, subjectIndex);
                    }
                    
                    cell.appendChild(taskList);

                    // --- 편집 가능성 및 이벤트 리스너 설정 ---
                    // 오늘 날짜(today)부터 수능일(suneungDate)까지의 날짜에만 편집 가능하도록 설정
                    if (cellDate >= today && cellDate <= suneungDate) { 
                        // 각 task-content에 직접 contenteditable 속성 부여 (처음엔 false)
                        taskList.querySelectorAll('.task-content').forEach(span => {
                            span.contentEditable = "true"; // 기본적으로 편집 가능하게 설정
                        });
                        // 삭제 버튼도 기본적으로 표시
                        taskList.querySelectorAll('.delete-task-btn').forEach(btn => {
                            btn.style.opacity = '1';
                        });


                        taskList.addEventListener('input', (event) => {
                             if (event.target.classList.contains('task-content')) {
                                 saveTasks(cell, dateKey);
                             }
                         });

                        taskList.addEventListener('change', (event) => {
                            if (event.target.type === 'checkbox') {
                                saveTasks(cell, dateKey);
                            }
                        });

                         // 삭제 버튼 클릭 이벤트 리스너
                         taskList.addEventListener('click', (event) => {
                             if (event.target.classList.contains('delete-task-btn')) {
                                 const liToRemove = event.target.closest('li');
                                 if (liToRemove) {
                                     taskList.removeChild(liToRemove);
                                     saveTasks(cell, dateKey); // 삭제 후 저장
                                 }
                             }
                         });
                         
                         // 엔터키 처리 로직
                         taskList.addEventListener('keydown', (e) => {
                            let currentContentSpan = e.target.closest('.task-content');
                            if (e.key === 'Enter' && !e.shiftKey && currentContentSpan && currentContentSpan.isContentEditable) {
                                e.preventDefault(); 
                                
                                const selection = window.getSelection();
                                const range = selection.getRangeAt(0);
                                
                                const newLi = document.createElement('li');
                                // 새 항목은 기본적으로 contenteditable="true"로 생성
                                newLi.innerHTML = `<input type="checkbox"> <span class="task-content" contenteditable="true"></span><button class="delete-task-btn" style="opacity:1;">[X]</button>`;
                                
                                const currentLi = currentContentSpan.closest('li');
                                if (currentLi) {
                                    taskList.insertBefore(newLi, currentLi.nextSibling);
                                } else {
                                    taskList.appendChild(newLi);
                                }

                                const newContentSpan = newLi.querySelector('.task-content');
                                if (newContentSpan) {
                                    newContentSpan.focus();
                                    const newRange = document.createRange();
                                    newRange.selectNodeContents(newContentSpan);
                                    newRange.collapse(true); 
                                    selection.removeAllRanges();
                                    selection.addRange(newRange);
                                }
                                saveTasks(cell, dateKey); 
                            }
                         });

                    } else {
                        // 오늘 이전 날짜는 편집 불가능하게 (contenteditable="false"는 기본값)
                        taskList.querySelectorAll('.task-content').forEach(span => {
                            span.contentEditable = "false";
                            span.style.cursor = "default"; // 커서를 기본으로 변경
                        });
                        // 삭제 버튼도 숨김
                        taskList.querySelectorAll('.delete-task-btn').forEach(btn => {
                            btn.style.display = 'none';
                        });
                    }
                }
                
                // 탐구 과목 인덱스는 studyStartDate 이후, 그리고 11월(month 10)이 아닐 때만 증가
                // 이제 today 이후의 모든 날짜에 기본 일정이 생성될 수 있도록 로직 변경
                if (cellDate >= today && cellDate.getMonth() === month && month !== 10) {
                    subjectIndex++; 
                }
                currentDate.setDate(currentDate.getDate() + 1); 
            }
            calendarContainer.appendChild(monthBlock);
        }

        // 기본 학습 항목을 생성하는 헬퍼 함수 (자율학습 제거, 1단원 제거)
        function generateDefaultTasks(taskList, cellDate, daysOfWeek, subjects, currentSubjectIndex) {
            const dayName = daysOfWeek[cellDate.getDay()];
            const isReviewDay = (dayName === "수요일" || dayName === "토요일");
            const maplTask = isReviewDay ? "마플 복습" : "마플 5장"; 
            
            const currentSubject = subjects[currentSubjectIndex % 2];
            const currentSubjectTask = isReviewDay ? `${currentSubject} 복습` : `${currentSubject}`; // '1단원' 제거
            
            taskList.innerHTML = `
                <li><input type="checkbox"> <span class="task-content">${("워드마스터 하이퍼 단어 외우기")}</span><button class="delete-task-btn">[X]</button></li>
                <li><input type="checkbox"> <span class="task-content">${("ENS 6문제")}</span><button class="delete-task-btn">[X]</button></li>
                <li><input type="checkbox"> <span class="task-content">${maplTask}</span><button class="delete-task-btn">[X]</button></li>
                <li><input type="checkbox"> <span class="task-content">${currentSubjectTask}</span><button class="delete-task-btn">[X]</button></li>
            `;
        }

        // 로컬 스토리지에 내용을 저장하는 함수
        function saveTasks(cell, dateKey) {
            const taskList = cell.querySelector('.task-list');
            if (!taskList) return;

            let tasks = [];
            taskList.querySelectorAll('li').forEach(li => {
                const checkbox = li.querySelector('input[type="checkbox"]');
                const contentSpan = li.querySelector('.task-content');
                const content = contentSpan ? contentSpan.textContent.trim() : ''; 
                tasks.push({
                    checked: checkbox ? checkbox.checked : false,
                    text: content
                });
            });
            localStorage.setItem(dateKey, JSON.stringify(tasks));
        }

        // 달력 렌더링 함수
        function renderCalendar() {
            createMonthCalendar(currentDisplayYear, currentDisplayMonth);
        }

        // 월 이동 버튼 이벤트 리스너
        prevMonthBtn.addEventListener('click', () => {
            currentDisplayMonth--;
            if (currentDisplayMonth < 0) {
                currentDisplayMonth = 11;
                currentDisplayYear--;
            }
            renderCalendar();
        });

        nextMonthBtn.addEventListener('click', () => {
            currentDisplayMonth++;
            if (currentDisplayMonth > 11) {
                currentDisplayMonth = 0;
                currentDisplayYear++;
            }
            renderCalendar();
        });

        // 데이터 백업 기능
        backupDataBtn.addEventListener('click', () => {
            const allCalendarData = {};
            for (let i = 0; i < localStorage.length; i++) {
                const key = localStorage.key(i);
                // 날짜 형식의 키만 백업 (YYYY-MM-DD)
                if (/^\d{4}-\d{2}-\d{2}$/.test(key)) {
                    allCalendarData[key] = JSON.parse(localStorage.getItem(key));
                }
            }

            const dataStr = JSON.stringify(allCalendarData, null, 2);
            const blob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const date = new Date();
            const dateString = `${date.getFullYear()}${(date.getMonth() + 1).toString().padStart(2, '0')}${date.getDate().toString().padStart(2, '0')}`;
            a.download = `suneung_calendar_backup_${dateString}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            alert('달력 데이터가 성공적으로 백업되었습니다!');
        });

        // 데이터 복원 기능
        restoreDataBtn.addEventListener('click', () => {
            restoreFileInput.click(); // 숨겨진 파일 입력 필드 클릭
        });

        restoreFileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (!file) {
                return;
            }

            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const restoredData = JSON.parse(e.target.result);
                    if (typeof restoredData !== 'object' || restoredData === null) {
                        throw new Error('유효하지 않은 JSON 형식입니다.');
                    }

                    // 기존 로컬 스토리지 데이터 중 달력 데이터만 지우기
                    for (let i = localStorage.length - 1; i >= 0; i--) {
                        const key = localStorage.key(i);
                        if (/^\d{4}-\d{2}-\d{2}$/.test(key)) {
                            localStorage.removeItem(key);
                        }
                    }

                    // 복원된 데이터 로컬 스토리지에 저장
                    for (const dateKey in restoredData) {
                        if (Object.prototype.hasOwnProperty.call(restoredData, dateKey) && /^\d{4}-\d{2}-\d{2}$/.test(dateKey)) {
                            localStorage.setItem(dateKey, JSON.stringify(restoredData[dateKey]));
                        }
                    }
                    alert('달력 데이터가 성공적으로 복원되었습니다!');
                    renderCalendar(); // 복원된 데이터로 달력 다시 렌더링
                } catch (error) {
                    alert('데이터 복원에 실패했습니다. 파일이 손상되었거나 올바른 형식이 아닙니다: ' + error.message);
                    console.error('데이터 복원 오류:', error);
                }
            };
            reader.readAsText(file);
            restoreFileInput.value = ''; // 같은 파일 다시 선택할 수 있도록 초기화
        });

        // 초기 달력 렌더링
        renderCalendar();
    </script>
</body>
</html>
